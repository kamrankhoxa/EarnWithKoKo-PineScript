// @EarnWithKoKo, KamranKhoxa
//@version=5
indicator(title='EarnWithKoKo_1.1', shorttitle='EWK_1', overlay=true, format=format.inherit , max_bars_back=5000)
input_diagonal = input.bool(false, "Diagonal Support", group="Support", confirm=true)
input_horizontal = input.bool(false, "Horizontal Support", group="Support", confirm=true)

//START LINEAR REGRESSION CHANNEL
src_lrgc = input(defval=close, title='Source')
len_lrgc = input.int(defval=100, title='Length', minval=10)
devlen_lrgc = input.float(defval=2., title='Deviation', minval=0.1, step=0.1)
extendit_lrgc = input(defval=true, title='Extend Lines')
showfibo_lrgc = input(defval=false, title='Show Fibonacci Levels')
showbroken_lrgc = input.bool(defval=false, title='Show Broken Channel', inline='brk')
brokencol_lrgc = input.color(defval=color.blue, title='', inline='brk')
upcol_lrgc = input.color(defval=color.lime, title='Up/Down Trend Colors', inline='trcols')
dncol_lrgc = input.color(defval=color.red, title='', inline='trcols')
widt_lrgc = input(defval=2, title='Line Width')


var fibo_ratios_lrgc = array.new_float(0)
var colors_lrgc = array.new_color(2)
if barstate.isfirst and input_diagonal
    array.unshift(colors_lrgc, upcol_lrgc)
    array.unshift(colors_lrgc, dncol_lrgc)
    array.push(fibo_ratios_lrgc, 0.236)
    array.push(fibo_ratios_lrgc, 0.382)
    array.push(fibo_ratios_lrgc, 0.618)
    array.push(fibo_ratios_lrgc, 0.786)


get_channel_lrgc(src, len) =>
    mid = math.sum(src, len) / len
    slope = ta.linreg(src, len, 0) - ta.linreg(src, len, 1)
    intercept = mid - slope * math.floor(len / 2) + (1 - len % 2) / 2 * slope
    endy = intercept + slope * (len - 1)
    dev = 0.0
    for x = 0 to len - 1 by 1
        dev := dev + math.pow(src[x] - (slope * (len - x) + intercept), 2)
        dev
    dev := math.sqrt(dev / len)
    [intercept, endy, dev, slope]

[y1_, y2_, dev, slope] = get_channel_lrgc(src_lrgc, len_lrgc)

outofchannel_lrgc = slope > 0 and close < y2_ - dev * devlen_lrgc ? 0 : slope < 0 and close > y2_ + dev * devlen_lrgc ? 2 : -1

var reglines_lrgc = array.new_line(3)
var fibolines_lrgc = array.new_line(4)
for x = 0 to 2 by 1
    if not showbroken_lrgc or outofchannel_lrgc != x or nz(outofchannel_lrgc[1], -1) != -1
        line.delete(array.get(reglines_lrgc, x))
    else
        line.set_color(array.get(reglines_lrgc, x), color=brokencol_lrgc)
        line.set_width(array.get(reglines_lrgc, x), width=2)
        line.set_style(array.get(reglines_lrgc, x), style=line.style_dotted)
        line.set_extend(array.get(reglines_lrgc, x), extend=extend.none)

    array.set(reglines_lrgc, x, line.new(x1=bar_index - (len_lrgc - 1), y1=y1_ + dev * devlen_lrgc * (x - 1), x2=bar_index, y2=y2_ + dev * devlen_lrgc * (x - 1), color=array.get(colors_lrgc, math.round(math.max(math.sign(slope), 0))), style=x % 2 == 1 ? line.style_solid : line.style_dashed, width=widt_lrgc, extend=extendit_lrgc ? extend.right : extend.none))
if showfibo_lrgc
    for x = 0 to 3 by 1
        line.delete(array.get(fibolines_lrgc, x))
        array.set(fibolines_lrgc, x, line.new(x1=bar_index - (len_lrgc - 1), y1=y1_ - dev * devlen_lrgc + dev * devlen_lrgc * 2 * array.get(fibo_ratios_lrgc, x), x2=bar_index, y2=y2_ - dev * devlen_lrgc + dev * devlen_lrgc * 2 * array.get(fibo_ratios_lrgc, x), color=array.get(colors_lrgc, math.round(math.max(math.sign(slope), 0))), style=line.style_dotted, width=widt_lrgc, extend=extendit_lrgc ? extend.right : extend.none))

var label sidelab_lrgc = label.new(x=bar_index - (len_lrgc - 1), y=y1_, text='S', size=size.large)
txt_lrgc = slope > 0 ? slope > slope[1] ? '⇑' : '⇗' : slope < 0 ? slope < slope[1] ? '⇓' : '⇘' : '⇒'
stl_lrgc = slope > 0 ? slope > slope[1] ? label.style_label_up : label.style_label_upper_right : slope < 0 ? slope < slope[1] ? label.style_label_down : label.style_label_lower_right : label.style_label_right
label.set_style(sidelab_lrgc, stl_lrgc)
label.set_text(sidelab_lrgc, txt_lrgc)
label.set_x(sidelab_lrgc, bar_index - (len_lrgc - 1))
label.set_y(sidelab_lrgc, slope > 0 ? y1_ - dev * devlen_lrgc : slope < 0 ? y1_ + dev * devlen_lrgc : y1_)
label.set_color(sidelab_lrgc, slope > 0 ? upcol_lrgc : slope < 0 ? dncol_lrgc : color.blue)

alertcondition(outofchannel_lrgc, title='Channel Broken', message='Channel Broken')

// direction
trendisup_lrgc = math.sign(slope) != math.sign(slope[1]) and slope > 0
trendisdown_lrgc = math.sign(slope) != math.sign(slope[1]) and slope < 0
alertcondition(trendisup_lrgc, title='Up trend', message='Up trend')
alertcondition(trendisdown_lrgc, title='Down trend', message='Down trend')



//END LINEAR REGRESSION CHANNEL
//*******************************************************


//BEAr and bull findeR
colors_obf = input.string(title='Color Scheme', defval='BRIGHT', options=['DARK', 'BRIGHT'])
periods_obf = input(5, 'Relevant Periods to identify OB')  // Required number of subsequent candles in the same direction to identify Order Block
threshold_obf = input.float(0.0, 'Min. Percent move to identify OB', step=0.1)  // Required minimum % move (from potential OB close to last subsequent candle to identify Order Block)
usewicks_obf = input(false, 'Use whole range [High/Low] for OB marking?')  // Display High/Low range for each OB instead of Open/Low for Bullish / Open/High for Bearish
showbull_obf = input(true, 'Show latest Bullish Channel?')  // Show Channel for latest Bullish OB?
showbear_obf = input(true, 'Show latest Bearish Channel?')  // Show Channel for latest Bearish OB?
showdocu_obf = input(false, 'Show Label for documentation tooltip?')  // Show Label which shows documentation as tooltip?
info_pan_obf = input(false, 'Show Latest OB Panel?')  // Show Info Panel with latest OB Stats

ob_period_obf = periods_obf + 1  // Identify location of relevant Order Block candle
absmove_obf = math.abs(close[ob_period_obf] - close[1]) / close[ob_period_obf] * 100  // Calculate absolute percent move from potential OB to last candle of subsequent candles
relmove_obf = absmove_obf >= threshold_obf  // Identify "Relevant move" by comparing the absolute move to the threshold

// Color Scheme
bullcolor_obf = colors_obf == 'DARK' ? color.white : color.green
bearcolor_obf = colors_obf == 'DARK' ? color.blue : color.red

// Bullish Order Block Identification
bullishOB_obf = close[ob_period_obf] < open[ob_period_obf]  // Determine potential Bullish OB candle (red candle)

int upcandles_obf = 0
for i = 1 to periods_obf by 1
    upcandles_obf := upcandles_obf + (close[i] > open[i] ? 1 : 0)  // Determine color of subsequent candles (must all be green to identify a valid Bearish OB)
    upcandles_obf

OB_bull_obf = bullishOB_obf and upcandles_obf == periods_obf and relmove_obf  // Identification logic (red OB candle & subsequent green candles)
OB_bull_high_obf = OB_bull_obf ? usewicks_obf ? high[ob_period_obf] : open[ob_period_obf] : na  // Determine OB upper limit (Open or High depending on input)
OB_bull_low_obf = OB_bull_obf ? low[ob_period_obf] : na  // Determine OB lower limit (Low)
OB_bull_avg_obf = (OB_bull_high_obf + OB_bull_low_obf) / 2  // Determine OB middle line


// Bearish Order Block Identification
bearishOB_obf = close[ob_period_obf] > open[ob_period_obf]  // Determine potential Bearish OB candle (green candle)

int downcandles_obf = 0
for i = 1 to periods_obf by 1
    downcandles_obf := downcandles_obf + (close[i] < open[i] ? 1 : 0)  // Determine color of subsequent candles (must all be red to identify a valid Bearish OB)
    downcandles_obf

OB_Bear_obf = bearishOB_obf and downcandles_obf == periods_obf and relmove_obf  // Identification logic (green OB candle & subsequent green candles)
OB_Bear_high_obf = OB_Bear_obf ? high[ob_period_obf] : na  // Determine OB upper limit (High)
OB_Bear_low_obf = OB_Bear_obf ? usewicks_obf ? low[ob_period_obf] : open[ob_period_obf] : na  // Determine OB lower limit (Open or Low depending on input)
OB_Bear_avg_obf = (OB_Bear_low_obf + OB_Bear_high_obf) / 2  // Determine OB middle line


// Plotting

plotshape(OB_bull_obf, title='Bullish OB', style=shape.triangleup, color=bullcolor_obf, textcolor=bullcolor_obf, size=size.tiny, location=location.belowbar, offset=-ob_period_obf, text='Bullish OB')  // Bullish OB Indicator
bull1_obf = plot(OB_bull_high_obf, title='Bullish OB High', style=plot.style_linebr, color=bullcolor_obf, offset=-ob_period_obf, linewidth=3)  // Bullish OB Upper Limit
bull2_obf = plot(OB_bull_low_obf, title='Bullish OB Low', style=plot.style_linebr, color=bullcolor_obf, offset=-ob_period_obf, linewidth=3)  // Bullish OB Lower Limit
fill(bull1_obf, bull2_obf, color=bullcolor_obf, title='Bullish OB fill', transp=0)  // Fill Bullish OB
plotshape(OB_bull_avg_obf, title='Bullish OB Average', style=shape.cross, color=bullcolor_obf, size=size.normal, location=location.absolute, offset=-ob_period_obf)  // Bullish OB Average


plotshape(OB_Bear_obf, title='Bearish OB', style=shape.triangledown, color=bearcolor_obf, textcolor=bearcolor_obf, size=size.tiny, location=location.abovebar, offset=-ob_period_obf, text='Bearish OB')  // Bearish OB Indicator
bear1_obf = plot(OB_Bear_low_obf, title='Bearish OB Low', style=plot.style_linebr, color=bearcolor_obf, offset=-ob_period_obf, linewidth=3)  // Bearish OB Lower Limit
bear2_obf = plot(OB_Bear_high_obf, title='Bearish OB High', style=plot.style_linebr, color=bearcolor_obf, offset=-ob_period_obf, linewidth=3)  // Bearish OB Upper Limit
fill(bear1_obf, bear2_obf, color=bearcolor_obf, title='Bearish OB fill', transp=0)  // Fill Bearish OB
plotshape(OB_Bear_avg_obf, title='Bearish OB Average', style=shape.cross, color=bearcolor_obf, size=size.normal, location=location.absolute, offset=-ob_period_obf)  // Bullish OB Average

var line linebull1_obf = na  // Bullish OB average 
var line linebull2_obf = na  // Bullish OB open
var line linebull3_obf = na  // Bullish OB low
var line linebear1_obf = na  // Bearish OB average
var line linebear2_obf = na  // Bearish OB high
var line linebear3_obf = na  // Bearish OB open


if OB_bull_obf and showbull_obf
    line.delete(linebull1_obf)
    linebull1_obf := line.new(x1=bar_index, y1=OB_bull_avg_obf, x2=bar_index - 1, y2=OB_bull_avg_obf, extend=extend.left, color=bullcolor_obf, style=line.style_solid, width=1)

    line.delete(linebull2_obf)
    linebull2_obf := line.new(x1=bar_index, y1=OB_bull_high_obf, x2=bar_index - 1, y2=OB_bull_high_obf, extend=extend.left, color=bullcolor_obf, style=line.style_dashed, width=1)

    line.delete(linebull3_obf)
    linebull3_obf := line.new(x1=bar_index, y1=OB_bull_low_obf, x2=bar_index - 1, y2=OB_bull_low_obf, extend=extend.left, color=bullcolor_obf, style=line.style_dashed, width=1)
    linebull3_obf

if OB_Bear_obf and showbear_obf
    line.delete(linebear1_obf)
    linebear1_obf := line.new(x1=bar_index, y1=OB_Bear_avg_obf, x2=bar_index - 1, y2=OB_Bear_avg_obf, extend=extend.left, color=bearcolor_obf, style=line.style_solid, width=1)

    line.delete(linebear2_obf)
    linebear2_obf := line.new(x1=bar_index, y1=OB_Bear_high_obf, x2=bar_index - 1, y2=OB_Bear_high_obf, extend=extend.left, color=bearcolor_obf, style=line.style_dashed, width=1)

    line.delete(linebear3_obf)
    linebear3_obf := line.new(x1=bar_index, y1=OB_Bear_low_obf, x2=bar_index - 1, y2=OB_Bear_low_obf, extend=extend.left, color=bearcolor_obf, style=line.style_dashed, width=1)
    linebear3_obf


// Alerts for Order Blocks Detection

alertcondition(OB_bull_obf, title='New Bullish OB detected', message='New Bullish OB detected - This is NOT a BUY signal!')
alertcondition(OB_Bear_obf, title='New Bearish OB detected', message='New Bearish OB detected - This is NOT a SELL signal!')

// Print latest Order Blocks in Data Window

var latest_bull_high_obf = 0.0  // Variable to keep latest Bull OB high
var latest_bull_avg_obf = 0.0  // Variable to keep latest Bull OB average
var latest_bull_low_obf = 0.0  // Variable to keep latest Bull OB low
var latest_bear_high_obf = 0.0  // Variable to keep latest Bear OB high
var latest_bear_avg_obf = 0.0  // Variable to keep latest Bear OB average
var latest_bear_low_obf = 0.0  // Variable to keep latest Bear OB low

// Assign latest values to variables
if OB_bull_high_obf > 0
    latest_bull_high_obf := OB_bull_high_obf
    latest_bull_high_obf

if OB_bull_avg_obf > 0
    latest_bull_avg_obf := OB_bull_avg_obf
    latest_bull_avg_obf

if OB_bull_low_obf > 0
    latest_bull_low_obf := OB_bull_low_obf
    latest_bull_low_obf

if OB_Bear_high_obf > 0
    latest_bear_high_obf := OB_Bear_high_obf
    latest_bear_high_obf

if OB_Bear_avg_obf > 0
    latest_bear_avg_obf := OB_Bear_avg_obf
    latest_bear_avg_obf

if OB_Bear_low_obf > 0
    latest_bear_low_obf := OB_Bear_low_obf
    latest_bear_low_obf

// Plot invisible characters to be able to show the values in the Data Window
plotchar(latest_bull_high_obf, char=' ', location=location.abovebar, color=color.new(#777777, 100), size=size.tiny, title='Latest Bull High')
plotchar(latest_bull_avg_obf, char=' ', location=location.abovebar, color=color.new(#777777, 100), size=size.tiny, title='Latest Bull Avg')
plotchar(latest_bull_low_obf, char=' ', location=location.abovebar, color=color.new(#777777, 100), size=size.tiny, title='Latest Bull Low')
plotchar(latest_bear_high_obf, char=' ', location=location.abovebar, color=color.new(#777777, 100), size=size.tiny, title='Latest Bear High')
plotchar(latest_bear_avg_obf, char=' ', location=location.abovebar, color=color.new(#777777, 100), size=size.tiny, title='Latest Bear Avg')
plotchar(latest_bear_low_obf, char=' ', location=location.abovebar, color=color.new(#777777, 100), size=size.tiny, title='Latest Bear Low')


//InfoPanel for latest Order Blocks

draw_InfoPanel(_text, _x, _y, font_size) =>
    var label la_panel = na
    label.delete(la_panel)
    la_panel := label.new(x=_x, y=_y, text=_text, xloc=xloc.bar_time, yloc=yloc.price, color=color.new(#383838, 5), style=label.style_label_left, textcolor=color.white, size=font_size)
    la_panel

info_panel_x_obf = time_close + math.round(ta.change(time) * 100)
info_panel_y_obf = close

title_obf = 'LATEST ORDER BLOCKS'
row0_obf = '-----------------------------------------------------'
row1_obf = ' Bullish - High: ' + str.tostring(latest_bull_high_obf, '#.##')
row2_obf = ' Bullish - Avg: ' + str.tostring(latest_bull_avg_obf, '#.##')
row3_obf = ' Bullish - Low: ' + str.tostring(latest_bull_low_obf, '#.##')
row4_obf = '-----------------------------------------------------'
row5_obf = ' Bearish - High: ' + str.tostring(latest_bear_high_obf, '#.##')
row6_obf = ' Bearish - Avg: ' + str.tostring(latest_bear_avg_obf, '#.##')
row7_obf = ' Bearish - Low: ' + str.tostring(latest_bear_low_obf, '#.##')

panel_text_obf = '\n' + title_obf + '\n' + row0_obf + '\n' + row1_obf + '\n' + row2_obf + '\n' + row3_obf + '\n' + row4_obf + '\n\n' + row5_obf + '\n' + row6_obf + '\n' + row7_obf + '\n'

if info_pan_obf
    draw_InfoPanel(panel_text_obf, info_panel_x_obf, info_panel_y_obf, size.normal)


// === Label for Documentation/Tooltip ===
chper_obf = time - time[1]
chper_obf := ta.change(chper_obf) > 0 ? chper_obf[1] : chper_obf

// === Tooltip text ===

var vartooltip_obf = 'Indicator to help identifying instituational Order Blocks. Often these blocks signal the beginning of a strong move, but there is a high probability, that these prices will be revisited at a later point in time again and therefore are interesting levels to place limit orders. \nBullish Order block is the last down candle before a sequence of up candles. \nBearish Order Block is the last up candle before a sequence of down candles. \nIn the settings the number of required sequential candles can be adjusted. \nFurthermore a %-threshold can be entered which the sequential move needs to achieve in order to validate a relevant Order Block. \nChannels for the last Bullish/Bearish Block can be shown/hidden.'

// === Print Label ===
var label l_docu = na
label.delete(l_docu)

if showdocu_obf
    l_docu := label.new(x=time + chper_obf * 35, y=close, text='DOCU OB', color=color.gray, textcolor=color.white, style=label.style_label_center, xloc=xloc.bar_time, yloc=yloc.price, size=size.tiny, textalign=text.align_left, tooltip=vartooltip_obf)
    l_docu




//AND BULL BEAr findeR
//**************************************
//START EXTRAPOLATED PIVOTE CONNECTOR


//----
length_ex_p_conn = input(100)
astart_ex_p_conn = input(1, 'A-High Position')
aend_ex_p_conn = input(0, 'B-High Position')
bstart_ex_p_conn = input(1, 'A-Low Position')
bend_ex_p_conn = input(0, 'B-Low Position')
csrc_ex_p_conn = input(false, 'Use Custom Source ?')
src_ex_p_conn = input(close, 'Custom Source')
//----
up_ex_p_conn = ta.pivothigh(csrc_ex_p_conn ? src_ex_p_conn : high, length_ex_p_conn, length_ex_p_conn)
dn_ex_p_conn = ta.pivotlow(csrc_ex_p_conn ? src_ex_p_conn : low, length_ex_p_conn, length_ex_p_conn)
//----
n_ex_p_conn = bar_index
a1_ex_p_conn = ta.valuewhen(not na(up_ex_p_conn), n_ex_p_conn, astart_ex_p_conn)
b1_ex_p_conn = ta.valuewhen(not na(dn_ex_p_conn), n_ex_p_conn, bstart_ex_p_conn)
a2_ex_p_conn = ta.valuewhen(not na(up_ex_p_conn), n_ex_p_conn, aend_ex_p_conn)
b2_ex_p_conn = ta.valuewhen(not na(dn_ex_p_conn), n_ex_p_conn, bend_ex_p_conn)
//----
line upper_ex_p_conn = line.new(n_ex_p_conn[n_ex_p_conn - a1_ex_p_conn + length_ex_p_conn], up_ex_p_conn[n_ex_p_conn - a1_ex_p_conn], n_ex_p_conn[n_ex_p_conn - a2_ex_p_conn + length_ex_p_conn], up_ex_p_conn[n_ex_p_conn - a2_ex_p_conn], extend=extend.right, color=color.blue, width=2)
line lower_ex_p_conn = line.new(n_ex_p_conn[n_ex_p_conn - b1_ex_p_conn + length_ex_p_conn], dn_ex_p_conn[n_ex_p_conn - b1_ex_p_conn], n_ex_p_conn[n_ex_p_conn - b2_ex_p_conn + length_ex_p_conn], dn_ex_p_conn[n_ex_p_conn - b2_ex_p_conn], extend=extend.right, color=color.orange, width=2)
line.delete(upper_ex_p_conn[1])
line.delete(lower_ex_p_conn[1])
//----
label ahigh_ex_p_conn = label.new(n_ex_p_conn[n_ex_p_conn - a1_ex_p_conn + length_ex_p_conn], up_ex_p_conn[n_ex_p_conn - a1_ex_p_conn], 'A-High', color=color.blue, style=label.style_label_down, textcolor=color.white, size=size.small)
label bhigh_ex_p_conn = label.new(n_ex_p_conn[n_ex_p_conn - a2_ex_p_conn + length_ex_p_conn], up_ex_p_conn[n_ex_p_conn - a2_ex_p_conn], 'B-High', color=color.blue, style=label.style_label_down, textcolor=color.white, size=size.small)
label alow_ex_p_conn = label.new(n_ex_p_conn[n_ex_p_conn - b1_ex_p_conn + length_ex_p_conn], dn_ex_p_conn[n_ex_p_conn - b1_ex_p_conn], 'A-Low', color=color.orange, style=label.style_label_up, textcolor=color.white, size=size.small)
label blow_ex_p_conn = label.new(n_ex_p_conn[n_ex_p_conn - b2_ex_p_conn + length_ex_p_conn], dn_ex_p_conn[n_ex_p_conn - b2_ex_p_conn], 'B-Low', color=color.orange, style=label.style_label_up, textcolor=color.white, size=size.small)
label.delete(ahigh_ex_p_conn[1])
label.delete(bhigh_ex_p_conn[1])
label.delete(alow_ex_p_conn[1])
label.delete(blow_ex_p_conn[1])
//----
plot(up_ex_p_conn, 'Pivot High\'s', color.new(color.blue, 0), 4, style=plot.style_circles, offset=-length_ex_p_conn, join=true)
plot(dn_ex_p_conn, 'Pivot Low\'s', color.new(color.orange, 0), 4, style=plot.style_circles, offset=-length_ex_p_conn, join=true)


//END OF PICK GOLDEN CROSS STRATEGY
//********************************************************
watermarki_supp = input.bool(true, "Watermark", group="Author Sign") //confirm=true)




string  i_tableYpos_oto_supp = input.string("top", "Position", inline = "12", options = ["top", "middle", "bottom"])
string  i_tableXpos_oto_supp = input.string("right", "", inline = "12", options = ["left", "center", "right"])
int     i_height_oto_supp    = input.int(7, "Height", minval = 1, maxval = 100, inline = "13")
int     i_width_oto_supp     = input.int(30, "Width",  minval = 1, maxval = 100, inline = "13a")
color   i_c_text_oto_supp    = input.color(color.new(color.white, 0), "", inline = "14")
color   _bg_oto_supp    = input.color(color.new(color.blue, 70), "", inline = "14")
string  i_textSize  = input.string("normal", "Size", inline = "14", options = ["tiny", "small", "normal", "large", "huge", "auto"])
i_text2_supp =  "EarnWithKoKo"
i_text1_supp =  "When using the indicator EarnWithKoKo thank you"
var table watermark_supp = table.new(i_tableYpos_oto_supp + "_" + i_tableXpos_oto_supp, 1, 1)
if barstate.islast and watermarki_supp
    varip bool _changeText_supp = true
    _changeText_supp := not _changeText_supp
    string _txt_supp = _changeText_supp ? i_text2_supp : i_text1_supp
    table.cell(watermark_supp, 0, 0, i_text2_supp, i_width_oto_supp, i_height_oto_supp, i_c_text_oto_supp, text_size = i_textSize, bgcolor = _bg_oto_supp)

//#!
showTF = input.bool(true, "show time frame", inline = "24")
showpf = input.bool(true, "show prefix title", inline = "24")
string  i_tableYpos = input.string("bottom", "Position", inline = "12", options = ["top", "middle", "bottom"])
string  i_tableXpos = input.string("center", "", inline = "12", options = ["left", "center", "right"])
size1 = input.string("huge", "title", inline = "14", options = ["tiny", "small", "normal", "large", "huge", "auto"])
size2 = input.string("auto", "extra", inline = "14", options = ["tiny", "small", "normal", "large", "huge", "auto"])
color = input.color(#999999, "color")
string = input.string("by EarnWithKoKo", "your signature")
seperator = input.string("/", "seperator")

cur = syminfo.currency
base = syminfo.basecurrency
exchange = syminfo.prefix

        
getTimeFrame() =>
    tf = timeframe.multiplier
    tfstr = ""
    if timeframe.isseconds
        tfstr := "s"
    if timeframe.isminutes
        if tf >= 60
            tf := tf / 60
            tfstr := "h"
        else
            tfstr := "m"
    if timeframe.isdaily
        tfstr := "D"
    if timeframe.isweekly
        tfstr := "W"
    if timeframe.ismonthly
        tfstr := "M"  
        
    [tfstr, str.tostring(tf)]
        
var table table1 = table.new(i_tableYpos + "_" + i_tableXpos , 3, 1)

if barstate.islast
    
    str1 = base + seperator + cur
    [tf, period] = getTimeFrame()

    table.cell(table1, 0, 0, showpf ? exchange : "", text_color = color,  text_size=size2)

    table.cell(table1, 1, 0, str1 + (showTF ? (" " + period + tf) : ""), text_color = color,  text_size=size1)

    table.cell(table1, 2, 0, string, text_color = color,  text_size=size2)




// ================================== //
// ------------> Tips <-------------- //
// ================================== //

leftTip         =   "Look left for swing high/low in x number of bars to form pivot"        
rightTip        =   "Look right for swing high/low in x number of bars to form pivot"      
nPivTip         =   "This sets the array size, or the number of pivots to track at a time (x highs, and x number of lows)" 
atrLenTip       =   "Number of bars to average. ATR is used to standardize zone width between assets and timeframes"     
multTip         =   "ATR multiplier to set zone width. Default is half of one ATR from box bottom to box top"     
perTip          =   "Max zone size as a percent of price. Some assets can be too volatile at low prices creating an unreasonably sized zone"
srcTip          =   "Source input for pivots. Default tracks the highest and lowest bodies of HA candles to average price action, whcih can result in a level that sits in the overlap of support and resistance"     
alignZonesTip   =   "Alligns recurring zones whos edges overlap an existing zone creating a zone that ages in time and intensifies visually"     
  
dhighsTip       =   "Disabling will prevent highs from being tracked"          
dlowsTip        =   "Disabling will prevent lows from being tracked"         
detectBOTip     =   "Show points that price action breaks above all pivots. An arrow from below is displayed"        
detectBDTip     =   "Show points that price action breaks below all pivots. An arrow from above is displayed"         
breakUpTip      =   "Show points that price action breaks above resistance. An arrow from below is displayed"         
breakDnTip      =   "Show points that price action breaks below support. An arrow from above is displayed"          
falseBullTip    =   "Show points that price action initially breaks below support before reversing. False moves can lead to fast moves in the opposite direction (bear trap). A large arrow from below is displayed"          
falseBearTip    =   "Show points that price action initially breaks above resistance before reversing. False moves can lead to fast moves in the opposite direction (bull trap). A large arrow from above is displayed"           
supPushTip      =   "Show up candles that are detected within a support zone. Can show points support is being respected. A triangle from below is displayed"          
resPushTip      =   "Show down candles that are detected within a resistance zone. Can show points resistance is being respected. A triangle from above is displayed"           
  
lookbackTip     =   "Number of candles that can be included in a false break signal"        
swingTip        =   "Swing detection is used to filter signals on breakout type signals. A higher number will mean more significant points, but less of them"        
pivotColorTip   =   "Color of key levels --> (bull color, bear color, transparency of box background, transparency of box borders)"            
breakoutTip     =   "Color of breakout arrows --> (bull, bear, transp., transp.)"           
SnRTip          =   "Color of triangles for broken support or resistance --> (bull, bear, transp., transp.)"   
falseBreakTip   =   "Color of arrows for false breaks --> (bull, bear, transp., transp., arrow max height in pixels)"            
moveTip         =   "Color of triangles for candles that are detected within zones --> (bull, bear, transp., transp.)"    

// ================================== //
// ---------> User Input <----------- //
// ================================== //

left            =   input.int       (20     ,   "Look Left"                     ,   group= "Zones"                , tooltip= leftTip)    
right           =   input.int       (15     ,   "Look Right"                    ,   group= "Zones"                , tooltip= rightTip)    
nPiv            =   input.int       (4      ,   "Number of Pivots"              ,   group= "Zones"                , tooltip= nPivTip)
atrLen          =   input.int       (30     ,   "ATR Length"                    ,   group= "Zones"                , tooltip= atrLenTip)
mult            =   input.float     (0.5    ,   "Zone Width (ATR)"              ,   group= "Zones"                , tooltip= multTip,                step   = 0.1)
per             =   input.float     (5,         "Max Zone Percent"              ,   group= "Zones"                , tooltip= perTip)
src             =   input.string    ("HA"   ,   "Source For Pivots"             ,   group= "Zones"                , tooltip= srcTip,                 options= ["HA", "High/Low Body", "High/Low"])
alignZones      =   input.bool      (true   ,   "Align Zones"                   ,   group= "Zones"                , tooltip= alignZonesTip)

dhighs          =   input.bool      (true   ,   "Detect Pivot Highs"            ,   group= "Detection"            , tooltip= dhighsTip)
dlows           =   input.bool      (true   ,   "Detect Pivot Lows"             ,   group= "Detection"            , tooltip= dlowsTip)
detectBO        =   input.bool      (false  ,   "Detect Breakout"               ,   group= "Detection"            , tooltip= detectBOTip)
detectBD        =   input.bool      (false  ,   "Detect Breakdown"              ,   group= "Detection"            , tooltip= detectBDTip)
breakUp         =   input.bool      (false  ,   "Detect Resistance Break"       ,   group= "Detection"            , tooltip= breakUpTip)
breakDn         =   input.bool      (false  ,   "Detect Support Break"          ,   group= "Detection"            , tooltip= breakDnTip) 
falseBull       =   input.bool      (false  ,   "Detect False Breakdown"        ,   group= "Detection"            , tooltip= falseBullTip)
falseBear       =   input.bool      (false  ,   "Detect False Breakup"          ,   group= "Detection"            , tooltip= falseBearTip) 
supPush         =   input.bool      (false  ,   "Detect Moves Off Support"      ,   group= "Detection"            , tooltip= supPushTip)
resPush         =   input.bool      (false  ,   "Detect Moves Off Resistance"   ,   group= "Detection"            , tooltip= resPushTip) 

lookback        =   input.int       (2      ,   "Lookback For Breaks"           ,   group= "Lookback"             , tooltip= lookbackTip)
swing           =   input.int       (5      ,   "swing High/Low"                ,   group= "Lookback"             , tooltip= swingTip)

bullCol         =   input.color     (#64b5f6,   ""   ,  inline="1"              ,   group= "Pivot Color")
bearCol         =   input.color     (#ffeb3b,   ""   ,  inline="1"              ,   group= "Pivot Color")
bgTransp        =   input.int       (75     ,   ""   ,  inline="1"              ,   group= "Pivot Color")   
bordTransp      =   input.int       (100    ,   ""   ,  inline="1"              ,   group= "Pivot Color"          , tooltip= pivotColorTip)

bullBreak       =   input.color     (#0000ff,   ""   ,  inline="2"              ,   group= "Breakout Color")
bearBreak       =   input.color     (#ff00ff,   ""   ,  inline="2"              ,   group= "Breakout Color")
bullTransp      =   input.int       (40     ,   ""   ,  inline="2"              ,   group= "Breakout Color")   
bearTransp      =   input.int       (40     ,   ""   ,  inline="2"              ,   group= "Breakout Color"       , tooltip= breakoutTip) 

resBreakCol     =   input.color     (#17ff00,   ""   ,  inline="3"              ,   group= "S&R Break Color")
supBreakCol     =   input.color     (#ff0000,   ""   ,  inline="3"              ,   group= "S&R Break Color")
resBreakTransp  =   input.int       (40     ,   ""   ,  inline="3"              ,   group= "S&R Break Color")   
supBreakTransp  =   input.int       (40     ,   ""   ,  inline="3"              ,   group= "S&R Break Color"      , tooltip= SnRTip) 

falseBullCol    =   input.color     (#17ff00,   ""   ,  inline="4"              ,   group= "False Break Color")
falseBearCol    =   input.color     (#ff0000,   ""   ,  inline="4"              ,   group= "False Break Color")
falseBullTransp =   input.int       (40     ,   ""   ,  inline="4"              ,   group= "False Break Color")   
falseBearTransp =   input.int       (40     ,   ""   ,  inline="4"              ,   group= "False Break Color") 
arrowMax        =   input.int       (75     ,   ""   ,  inline="4"              ,   group= "False Break Color"    , tooltip= falseBreakTip) 

moveBull        =   input.color     (#64b5f6,   ""   ,  inline="5"              ,   group= "Moves From S&R Color")
moveBear        =   input.color     (#ffeb3b,   ""   ,  inline="5"              ,   group= "Moves From S&R Color")
moveBullTransp  =   input.int       (40     ,   ""   ,  inline="5"              ,   group= "Moves From S&R Color")   
moveBearTransp  =   input.int       (40     ,   ""   ,  inline="5"              ,   group= "Moves From S&R Color" , tooltip= moveTip) 

alertMode       =   input.string    (alert.freq_once_per_bar_close              ,   "Alerts Mode" ,                 group  = "Alert Frequency",     options= [alert.freq_once_per_bar, alert.freq_once_per_bar_close]) 

// ================================== //
// -----> Immutable Constants <------ //
// ================================== //    
 
sync            =   bar_index
confirmed       =   barstate.isconfirmed
var pivotHigh   =   array.new_box   (nPiv)
var pivotLows   =   array.new_box   (nPiv)  
var highBull    =   array.new_bool  (nPiv)
var lowsBull    =   array.new_bool  (nPiv)
var bullBorder  =   color.new       (bullCol,       bordTransp)
var bullBgCol   =   color.new       (bullCol,       bgTransp)
var bearBorder  =   color.new       (bearCol,       bordTransp)
var bearBgCol   =   color.new       (bearCol,       bgTransp)
var upCol       =   color.new       (bullBreak,     bullTransp)
var dnCol       =   color.new       (bearBreak,     bearTransp)
var supCol      =   color.new       (resBreakCol,   resBreakTransp)
var resCol      =   color.new       (supBreakCol,   supBreakTransp)
var fBull       =   color.new       (falseBullCol,  falseBullTransp)
var fBear       =   color.new       (falseBearCol,  falseBearTransp)
var moveBullCol =   color.new       (moveBull,      moveBullTransp)
var moveBearCol =   color.new       (moveBear,      moveBearTransp)

haSrc           =   src ==          "HA"    
hiLoSrc         =   src ==          "High/Low"

// ================================== //
// ---> Functional Declarations <---- //
// ================================== //

_haBody()       =>
    haClose     =   (open + high  +  low  + close)    / 4
    haOpen      =   float(na)
    haOpen      :=  na(haOpen[1]) ? (open + close)    / 2 : 
                   (nz(haOpen[1]) + nz(haClose[1]))   / 2
    
    [haOpen, haClose]

_arrayLoad(_x, _max, _val) =>  
    array.unshift                               (_x,   _val)   
    if  array.size                              (_x) > _max
        array.pop                               (_x)

_getBox(_x,_i)   =>
    _box         =             array.get        (_x,_i)
    _t           =             box.get_top      (_box)
    _b           =             box.get_bottom   (_box)
    [_t, _b]
    
_align(_x,_y)    =>
    for i = 0 to               array.size       (_x) -1
        [_T, _B] =             _getBox          (_y, 0)
        [_t, _b] =             _getBox          (_x, i)
        if _T > _b and         _T < _t or 
           _B < _t and         _B > _b or 
           _T > _t and         _B < _b or 
           _B > _b and         _T < _t
            box.set_top        (array.get       (_y, 0), _t)
            box.set_bottom     (array.get       (_y, 0), _b)

_extend(_x) =>
    for i = 0 to               array.size       (_x)-1
        box.set_right          (array.get       (_x, i), sync)
 
_color(_x, _y)     =>
    var int _track = nPiv
    for i = 0 to               array.size       (_x) -1
        [t_, b_] =             _getBox          (_x, i)
        _isBull  =             array.get        (_y, i)
        if close > t_ and not  _isBull
            array.set(_x, i, 
                      box.new( sync, t_, sync,  b_, 
                               xloc           = xloc.bar_index,
                               border_color   = bullBorder,   
                               bgcolor        = bullBgCol))      
            array.set(_y, i, true)
            _track += 1
        if close < b_ and _isBull
            array.set(_x, i, 
                      box.new( sync, t_, sync,  b_, 
                               xloc           = xloc.bar_index,
                               border_color   = bearBorder,   
                               bgcolor        = bearBgCol))  
            array.set(_y, i, false)
            _track -= 1
    _track

_detect(_x,_y)      =>
    int  _i         = 0
    bool _found     = false
    bool _isBull    = na
    while (not _found and _i <  array.size      (_x)  )
        [t_, b_] =              _getBox         (_x,_i)
        if low < t_ and high >  b_
            _isBull :=          array.get       (_y,_i)
            _found  :=          true
        _i          +=          1
    [_found, _isBull]

falseBreak(_l)      =>       
    bool _d         = false
    bool _u         = false
    for i = 1 to lookback
        if _l[i] < _l and _l[i+1] >= _l and _l[1] < _l 
            _d      := true
        if _l[i] > _l and _l[i+1] <= _l and _l[1] > _l 
            _u      := true
    [_d, _u]

_numLevel(_x,_y)    =>
    int _above      = 0
    int _fill       = 0
    for i = 0 to                array.size      (_x)-1
        _isBull     =           array.get       (_x,i)
        if  _isBull
            _above += 1
        if  not na(_isBull)
            _fill  += 1
    for i = 0 to                array.size      (_y)-1
        _isBull     =           array.get       (_y,i)
        if  _isBull
            _above += 1
        if  not na(_isBull)
            _fill  += 1
    [_above, _fill]  

_check(_src,_l) =>
    bool _check = false
    for i = 0 to _l
        if _src[i]
            _check := true
    _check

// ================================== //
// ----> Variable Calculations <----- //
// ================================== //

highest         =   close ==            ta.highest      (close,     right)
lowest          =   close ==            ta.lowest       (close,     right)

closeLows       =   ta.lowest           (close,          swing)
closeHigh       =   ta.highest          (close,          swing)

[open_, close_] =   _haBody             ()

hiHaBod         =   math.max            (close_,        open_)
loHaBod         =   math.min            (close_,        open_)

hiBod           =   math.max            (close,         open)
loBod           =   math.min            (close,         open)

srcHigh         =   haSrc ?             hiHaBod :       hiLoSrc ?   high :      hiBod
srcLow          =   haSrc ?             loHaBod :       hiLoSrc ?   low  :      loBod

pivot_high      =   ta.pivothigh        (srcHigh,       left,       right)
pivot_low       =   ta.pivotlow         (srcLow,        left,       right)

perc            =   close*              (per/100)
atr             =   ta.atr              (atrLen)*       mult

band            =   math.min            (atr,           perc)       [right]     /2

HH              =   pivot_high+         band
HL              =   pivot_high-         band

LH              =   pivot_low+          band
LL              =   pivot_low-          band

coDiff          =   close -             open

// ================================== //
// --------> Logical Order <--------- //
// ================================== //

if pivot_high and   dhighs and  confirmed and input_horizontal
    _arrayLoad      (highBull,  nPiv,   false)      
    _arrayLoad      (pivotHigh, nPiv,   box.new( sync[right],       HH, sync, HL, 
                                                 xloc           =   xloc.bar_index,
                                                 border_color   =   bearBorder,   
                                                 bgcolor        =   bearBgCol))

if pivot_low and    dlows and   confirmed and input_horizontal
    _arrayLoad      (lowsBull,  nPiv,   true)      
    _arrayLoad      (pivotLows, nPiv,   box.new( sync[right],       LH, sync, LL,    
                                                 xloc           =   xloc.bar_index,
                                                 border_color   =   bullBorder, 
                                                 bgcolor        =   bullBgCol))

if alignZones and input_horizontal
    _align          (pivotHigh,         pivotHigh)
    _align          (pivotHigh,         pivotLows)    
    _align          (pivotLows,         pivotLows)
    _align          (pivotLows,         pivotHigh)

_extend             (pivotHigh)
_extend             (pivotLows)

trackHigh       =   _color              (pivotHigh,     highBull)
trackLows       =   _color              (pivotLows,     lowsBull)

// ================================== //
// ----> Conditional Parameters <---- //
// ================================== //

isLows          =   closeLows      ==   close
isHigh          =   closeHigh      ==   close

wasLows         =   _check              (isLows,        lookback)
wasHigh         =   _check              (isHigh,        lookback)

[above, total]  =   _numLevel           (highBull,      lowsBull)

moveAbove       =   trackHigh       >   trackHigh[1]
moveBelow       =   trackLows       <   trackLows[1]

resBreak        =   (trackLows      >   trackLows[1]    or  moveAbove) 
supBreak        =   (trackHigh      <   trackHigh[1]    or  moveBelow) 

breakOut        =   moveAbove     and   highest and     above == total             
breakDwn        =   moveBelow     and   lowest  and     above == 0         

[dh, uh]        =   falseBreak          (trackHigh) 
[dl, ul]        =   falseBreak          (trackLows) 

falseBreakBull  =   wasLows       and   (dh or dl)
falseBreakBear  =   wasHigh       and   (uh or ul)

[fh,hb]         =   _detect             (pivotHigh,     highBull)
[fl,lb]         =   _detect             (pivotLows,     lowsBull)

bullCheck       =   not resBreak  and   not resBreak[1] and (fh or fl) and  close > open and     (hb or lb)
bearCheck       =   not supBreak  and   not supBreak[1] and (fh or fl) and  close < open and not (hb or lb)

// ================================== //
// ------> Graphical Display <------- //
// ================================== //

plotFalseDn     =   falseBull     and   falseBreakBull
plotFalseUp     =   falseBear     and   falseBreakBear

falseUpCol      =   plotFalseUp     ?   upCol       :   na
falseDnCol      =   plotFalseDn     ?   dnCol       :   na

plotBreakOut    =   breakOut      and   detectBO    and not         plotFalseDn
plotBreakDn     =   breakDwn      and   detectBD    and not         plotFalseUp

plotResBreak    =   resBreak      and   breakUp     and not         (plotBreakOut or plotFalseDn)
plotSupBreak    =   supBreak      and   breakDn     and not         (plotBreakDn  or plotFalseUp)

plotBullCheck   =   bullCheck     and   supPush
plotBearCheck   =   bearCheck     and   resPush

plotarrow           (plotFalseUp    ?   coDiff      :   na      ,   colorup  = fBull,               colordown=      fBear,          maxheight=      arrowMax)
plotarrow           (plotFalseDn    ?   coDiff      :   na      ,   colorup  = fBull,               colordown=      fBear,          maxheight=      arrowMax)

plotshape           (plotBreakOut   ,   style=shape.arrowup     ,   location=location.belowbar,     color=          upCol)
plotshape           (plotBreakDn    ,   style=shape.arrowdown   ,   location=location.abovebar,     color=          dnCol)

plotshape           (plotResBreak   ,   style=shape.arrowup     ,   location=location.belowbar,     color=          supCol)
plotshape           (plotSupBreak   ,   style=shape.arrowdown   ,   location=location.abovebar,     color=          resCol)

plotshape           (plotBullCheck  ,   style=shape.triangleup  ,   location=location.belowbar,     color=          moveBullCol)
plotshape           (plotBearCheck  ,   style=shape.triangledown,   location=location.abovebar,     color=          moveBearCol)

// ================================== //
// -----> Alert Functionality <------ //
// ================================== //

alertcondition      (resBreak       ,   'Resistance break'      ,   'Resistance broke on {{interval}} chart. Price is {{close}}')
alertcondition      (supBreak       ,   'Support break'         ,   'Support broke on {{interval}} chart. Price is {{close}}')

alertcondition      (bullCheck      ,   'Found Support'         ,   'Pushing Off Key Level Support on {{interval}} chart. Price is {{close}}')
alertcondition      (bearCheck      ,   'Found Resistance'      ,   'Pushing Off Key Level Resistance on {{interval}} chart. Price is {{close}}')

alertcondition      (falseBreakBull ,   'False Break Down'      ,   'False Break Down on {{interval}} chart. Price is {{close}}')
alertcondition      (falseBreakBear ,   'False Break Up'        ,   'False Break Up on {{interval}} chart. Price is {{close}}')

alertcondition      (breakOut       ,   'Breakout'              ,   'Breakout on {{interval}} chart. Price is {{close}}')
alertcondition      (breakDwn       ,   'Breakdown'             ,   'Breakdown on {{interval}} chart. Price is {{close}}')

if plotResBreak
    alert           ('Resistance broke on '                     +   timeframe.period + ' chart. Price is ' + str.tostring(close), alertMode)

if plotSupBreak
    alert           ('Resistance broke on '                     +   timeframe.period + ' chart. Price is ' + str.tostring(close), alertMode)

if plotBullCheck
    alert           ('Pushing Off Key Level Support on '        +   timeframe.period + ' chart. Price is ' + str.tostring(close), alertMode)

if plotBearCheck
    alert           ('Pushing Off Key Level Resistance on '     +   timeframe.period + ' chart. Price is ' + str.tostring(close), alertMode)

if plotFalseDn
    alert           ('False Break Down on '                     +   timeframe.period + ' chart. Price is ' + str.tostring(close), alertMode)

if plotFalseUp 
    alert           ('False Break Up on '                       +   timeframe.period + ' chart. Price is ' + str.tostring(close), alertMode)

if plotBreakOut
    alert           ('Breakout on '                             +   timeframe.period + ' chart. Price is ' + str.tostring(close), alertMode)

if plotBreakDn
    alert           ('Breakdown on '                            +   timeframe.period + ' chart. Price is ' + str.tostring(close), alertMode)

// END

